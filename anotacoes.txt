De qualquer forma, quando um sistema ou processo acessa o outro para trocar informações falamos de integração
A maneira de integração mais difundida hoje em dia está no uso de Web Services. Existem várias maneiras de se implementar um Web Service, mas apesar de ser um termo genérico, existe algo muito bem especificado pela W3C:
precisaríamos aproveitar toda a plataforma, arquitetura e protocolos já existentes a fim de minimizar o impacto de integrar sistemas.
o Web Service do W3C é baseado em HTTP e XML, duas tecnologias onipresentes e que a maioria das linguagens sabe trabalhar muito bem

o Java já vem com as principais classes para se conectar com recursos na rede.

Quando os serviços Web surgiram e ganharam popularidade as primeiras bibliotecas eram exclusivamente do servidor de aplicação. Isso significa que na época era preciso usar um servidor de aplicação para publicar o serviço web. Isso mudou e as classes para rodar um Web Service SOAP foram embutidas na JRE.
as bibliotecas são organizadas em especificações. SOAP se chama JAX-WS (Java API for XML - Web Service) e a sua implementação referencial, o Metro (https://jax-ws.java.net/), está embutida na JRE.


Devemos usar a anotação @WebService. Ou seja, a nossa intenção é chamar aquele método usando HTTP e XML:
Como não estamos usando um servidor formal é preciso publicar o serviço programaticamente.
No mundo de serviços web isso é chamado de publicar o Endpoint
O Endpoint é o endereço concreto do serviço. A classe Endpoint possui o papel de associar a nossa implementação EstoqueWS com uma URL:

WSDL significa Web Service Description Language e não é nada mais do que um XML que descreve o nosso serviço! Nele temos todas as informações, independente do Java, que um cliente precisa para chamar o Endpoint.
Para ser correto, SOAP e WSDL são especificações independentes do W3C (http://www.w3c.org) mas normalmente vem em conjunto.
uma ferramenta que irá interpretar o WSDL e gerar um cliente que sabe usar o nosso serviço SoapUI

Serviços Web são utilizados para integrar sistemas
SOAP é XML que trafega em cima do protocolo HTTP
o JRE já vem com o JAX-WS (Metro) para usar SOAP
o contrato do serviço é o WSDL que também é um XML
uma mensagem SOAP possui um Envelope e um Body,
na mensagem SOAP o Header é opcional

O SOAP é um padrão ou protocolo que define o XML que trafega entre Cliente e Servidor quando o serviço web é executado.Esse XML também é chamado de mensagem SOAP.
Ela consiste de três partes: um Envelope que é o elemento raiz. Dentro dele pode ter um Header para definir meta-informações como tokens, senha, etc e um Body que contem os dados principais da mensagem:

O elemento Content-type é um cabeçalho do protocolo HTTP, não é relacionado com o mundo SOAP. 
O elemento Header é opcional e pode conter informações que não são relacionados com os dados principais da mensagem SOAP.

informações sobre o usuário (autenticação e autorização)
data da criação da mensagem e tempo de validade
tempo máximo que a mensagem deve ser processada
prioridade da mensagem
identificação da transação
entre várias outras possibilidades
Importante é que o Header deve ser sempre o primeiro elemento filho do Envelope.

O que é integração de aplicações ou sistemas?
Compartilhar funcionalidades entre aplicações

Das afirmações abaixo, qual caracteriza melhor um serviço web?

Um serviço web roda na web :) Ou seja, devemos usar o protocolo HTTP. funciona em qualquer lugar. usar um formato de dados independente da plataforma de desenvolvimento. Formatos populares são XML e JSON mas existem outros.

No mundo Enterprise existe o SOAP outra opção é o modelo REST que se baseia fortemente no protocolo HTTP e usa muitas vezes o JSON como formato de dados.

JAX-RS, especificação para criar serviços web baseado no REST
JAX-B, especificação para mapear (binding) XML para objetos Java
JAX-RPC, antigo padrão de serviços web, o nome antigo do JAX-WS
JAX-P, especificação para ler e escrever XML (processing)


é raríssimo um sistema funcionar de forma isolada. Sendo sempre necessário fazer integração com outros sistemas que não foram desenhadas com esse propósito. Para resolver esse problema, podemos usar os mais diversos estilos de integração. Dentre eles:

Troca de arquivos
Banco de dados compartilhado
RPC
Mensageria
A questão é que cada estilo tem suas vantagens e desvantagens. É por isso que é papel do arquiteto pensar em algumas questões antes de decidir qual estilo aplicar:

Vamos trocar funcionalidades ou apenas dados?
Quais dados trocaremos?
Qual protocolos utilizaremos?
A comunicação será síncrona ou assíncrona?
Quais ferramentas/frameworks utilizaremos?
Entre outros ...

Nesse treinamento focaremos no estilo RPC (Remote Procedure Call). Objetivo desse estilo de integração é chamar um procedimento remotamente (via rede usamos HTTP com SOAP). No mundo Java este procedimento é um método.

RPC segue o modelo cliente-server (síncrono) que já testamos nesse capítulo. O SoapUI foi o cliente e rodamos o server através do JRE!

As anotações @WebService, @WebMethod e @WebResult são da especificação JAX-WS. A anotação @XmlElement é do JAX-B e serve para redefinir o nome do elemento no XML (entre outras funções).

O JAX-WS usa por baixo dos panos o JAX-B para gerar o XML. Importante é que todas as anotações tem um impacto no XML WSDL e SOAP gerado.
A anotação para manipular o retorno é o @WebResult
SOAP usa o padrão Wrapped (embrulhado)
essa TAG <ns2:todosOsItensResponse> 
é usada para indicar de qual método veio essa resposta. No nosso caso, do método todosItens anotado com @WebMethod(operationName="todosOsItens").
No mundo Java Web existe o JSESSIONID que representa um token utilizado em aplicações Web. O padrão de autenticação e autorização OAuth também usa um token. Enfim, o nosso sistema não vai reinventar a roda e também usará um token!
O header que indica que o parâmetro deve ser adicionado ao cabeçalho:
Fault no WSDL
No mundo SOAP não existem exceções e sim Faults. Uma exceção no mundo Java é traduzido para um Fault.
Um Fault possui um faultcode que indica se o problema foi do servidor ou do cliente, o faultstring com uma mensagem mais amigável e um detail que é a instância da exceção serializada em XML.
Cabeçalhos servem para guardar informações dados da aplicação
o elemento Header vem antes do Body
A anotação @WebParam serve para definir o Header
Exceptions são mapeadas para Faults
Em ambiente SOAP é bem comum trabalharmos com alguns intermediários entre cliente e server que validam os Headers e até os manipulam. 
um intermediário que verifica os dados de autenticação/autorização antes da mensagem chegar no servidor final.
outro poderia fazer uma auditoria para logar informações importantes do que está sendo feito.
nós o chamamos de Node (nó):

No mundo Java as exceções são mapeadas para Faults. O JAX-WS define duas categorias ou tipos de exceções:

Modeled (Modelado) - Para mapear uma exceção explicitamente a partir da lógica de negócios no código Java. As definições desse Fault estão no arquivo WSDL, as falhas SOAP são previstas no WSDL.

Unmodeled (Não modelado) - Para mapear uma exceção (normalmente do tipo java.lang.RuntimeException) que acontecerá em tempo de execução se alguma lógica falha. Neste caso, as exceções Java são representados como falha SOAP genérico.

unchecked não aparecem no wsdl
Cada Fault deve ter no mínimo um <faultcode> e <faultstring>
Para alterar o conteúdo do elemento <detail> é preciso um método getFaultInfo():

<faultcode> - Server ou Client para indicar onde ocorreu o problema, mas existem outros como VersionMissmatch
<faultstring> - uma explicação do Fault legível para humanos
<detail> - mais informações sobre o Fault, normalmente específicas da aplicação
O <faultcode> e <faultstring> são obrigatórios.

new ItemValidador(item).validate(). Ao chamar o validador lança uma ItemValidadorException caso o item esteja inválido. Essa exceção é unchecked, ou seja, não faz parte do WSDL.

não temos mais um <detail> mas sim um fault
<S:Fault xmlns:ns4="http://www.w3.org/2003/05/soap-envelope">

O Fault é mais genérico, não possui um elemento <detail>. A exceção não faz parte do WSDL, nem adianta colocar @WebFault.
Devemos agora dizer na nossa classe TokenUsuario que gostariamos de usar o Adapter que criamos para o atributo dataValidade. Para isso, usaremos a anotação @XmlJavaTypeAdapter:
precisamos dizer que essa classe é um adapter do JAX-B. Para isso, iremos extender a classe abstrata XmlAdapter.